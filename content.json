{"pages":[],"posts":[{"title":"关于我","text":"你好，我是 xin，现在是一名软件工程师，这里是我的个人博客。","link":"/2022/01/01/myself/"},{"title":"对于TDD(测试驱动开发)的理解与实践","text":"什么是TDD？测试驱动开发，英文全称 Test-Driven Development，简称 TDD，是一种有别于传统的开发方法。 简单来说：TDD 这种开发方法，就是让我们在设计一个功能时，先写用于测试这个功能的单元测试代码，再写具体实现的产品代码。 具体的使用方式是这样的：我们先写好一个单元测试的一小部分代码，然后开始编写这个功能的产品代码，让这些测试能够编译，产品代码够用即可，然后再回头接着写单元测试代码。这个循环不断反复。写一些测试代码，然后再写一些产品代码。这两套代码同步增长，互为补充。测试代码之匹配于产品代码，就如抗体之匹配于抗原一样。 TDD的三项法则 在编好失败单元测试之前，不要编写任何产品代码。 只要有一个单元测试失败了，就不要再写测试代码；无法通过编译也是一种失败。 产品代码恰好能够让当前失败的单元测试成功通过即可，不要多写。 为什么要使用TDD？TDD是专业主义的保障什么是专业主义？在《程序员的职业素养》一书中，作者提到：“代码中难免会出现 bug，但这并不意味着你不用对它们负责；没人能写出完美的软件，但这并不表示你不用对不完美负责。所谓专业人士，就是能对自己犯下的错误负责的人。失误率永远不可能等于零，但你有责任让它无限接近零。” 作为一个有追求的程序员，我们应该达成一个共识，那就是没有对例行程序进行测试就交付软件是不负责任的。如果产品有众多错误，对于开发这个产品的我们来说，就是一种耻辱。公司付给我们薪水，是为了要我们制造出如预期一般可以正常使用的产品，这是首要条件。 那么我们如何才能将错误率降到最低呢？很简单，不断的测试，以确保我们的正确。不是在做完之后点几下鼠标，而是在做的过程中就测试，不断的测试，几乎每30秒就测试一次，并且我们需要尽量高覆盖的单元测试，因为如果无法确保90%以上的覆盖，我们就难以放心。 TDD 就是这样做的，只要使用 TDD 的方法来编写程序，我们就可以得到一个覆盖90%以上的经过不断测试的产品。这保障了我们的专业主义。 TDD可以增加工作效率你是否认为编写测试会浪费太多的时间，当工期很紧急时，我们只能放弃测试埋头于业务代码？ 首先，编写测试绝对不是浪费时间的行为。如果没有测试，我们可能会面临多次的返工。并且通常在一个项目中，后期维护与修改的时间要大于开发的时间。编写测试，可以减少我们的返工次数，提高我们后期维护的工作效率。 更重要的是，使用 TDD 的方法来编写测试，是非常容易的。有些代码你可能会觉得难以测试，但那是因为在设计时就没考虑如何测试，唯一的解决办法就是要设计出易于测试的代码，最好是先写测试，再写要测的代码，这也就是测试驱动开发（TDD）。 TDD让我们无所畏惧看这张图： 无论是他人的代码，还是我们自己写的代码，过了一段时间后，我们很可能会丧失修改它的自信，因为我们总是会担心我们的修改会破坏一些原有的设计。有了 TDD 就不一样了，当看见糟糕的代码时，就可以放手去改，因为我们只要运行一下单元测试就可以确定修改是否正确了！ 最令人安心的一件事是，在任何时刻，一旦修改了程序的任何部分，只需再次运行全部的单元测试，通过了，就可以交付了。 TDD让代码变得更优雅先写测试，会迫使你去考虑更好的设计。这样你就不会去随意调用函数，增加耦合度了，因为你需要确保产品代码可以通过它对应的测试。 TDD实践以下将使用 Go 语言进行 TDD 实践。 使用TDD编写函数假设有以下需求：我们需要编写一个工具函数，用于将字符串数组转化为逗号分割的字符串形式 [“str1”,”str2”,”str3”] &gt;&gt; “str1,str2,str3”。 打算把这个工具函数放在 util/common.go 文件中，于是新建一个文件 util/common_test.go 用于放置单元测试。 开始编写单元测试： 123456789101112131415package utilsimport ( &quot;reflect&quot; &quot;testing&quot;)func TestStrListToString(t *testing.T) { StrList := []string{&quot;str1&quot;, &quot;str2&quot;, &quot;str3&quot;} got := StrListToString(StrList) want := &quot;str1,str2,str3&quot; if !reflect.DeepEqual(got, want) { t.Errorf(&quot;The values of %v is not %v\\n&quot;, got, want) }} 编写产品代码： 123456789func StrListToString(strList []string) (str string) { if len(strList) &gt; 0 { for _, v := range strList { str = str + &quot;,&quot; + v } return } return &quot;&quot;} 运行测试： 测试失败了，我们得到了 “,str1,str2,str3” 而不是预想的 “str1,str2,str3”。 修改产品代码： 12345678910111213func StrListToString(strList []string) (str string) { if len(strList) &gt; 0 { for k, v := range strList { if k == 0 { str = v } else { str = str + &quot;,&quot; + v } } return } return &quot;&quot;} 再次运行测试： 成功了！ 我们可以再新增其他的测试用例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package utilsimport ( &quot;reflect&quot; &quot;testing&quot;)type testStrListToStringCase struct { strList []string want string}var testStrListToStringGroup = []testStrListToStringCase{ // 测试用例1:单个英文 { strList: []string{&quot;str1&quot;}, want: &quot;str1&quot;, }, // 测试用例2:多个英文 { strList: []string{&quot;str1&quot;, &quot;str2&quot;, &quot;str3&quot;}, want: &quot;str1,str2,str3&quot;, }, // 测试用例3:逗号 { strList: []string{&quot;a,b,c&quot;}, want: &quot;a,b,c&quot;, }, // 测试用例4:汉字 { strList: []string{&quot;一二三四五&quot;}, want: &quot;一二三四五&quot;, }, // 测试用例5:空字符串 { strList: []string{&quot;&quot;}, want: &quot;&quot;, },}func TestStrListToString(t *testing.T) { for _, test := range testStrListToStringGroup { got := StrListToString(test.strList) if !reflect.DeepEqual(got, test.want) { t.Errorf(&quot;The values of %v is not %v\\n&quot;, got, test.want) } }} 运行测试： 成功。 使用 Go 的 testing 包，我们可以方便的查看测试覆盖率，只需要运行 go test -cover 即可。 还可以使用 go test -cover -coverprofile=test_report.out 导出报告文件，然后使用 go tool cover -html=test_report.out 以 HTML 的方式打开测试报告文件。 使用TDD编写接口假设有以下需求：我们需要编写一个接口，通过调用这个接口创建一个运营渠道，渠道需要字段（渠道名称，联系人，手机号）。 可以使用 go 的 httptest 接口进行测试，这样无需启动 web server 就可以发送一个真正的 http request。 编写测试： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 用于获取测试用户 tokenfunc GetAuthorization(userId string) (string, error) { claims := &amp;ctx.JWTClaims{ UserID: userId, } token, err := ctx.GetToken(claims) if err != nil { return &quot;&quot;, err } return token, nil}func performRequest(param map[string]interface{}, token string, r http.Handler, method, path string) *httptest.ResponseRecorder { jsonByte, _ := json.Marshal(param) req, _ := http.NewRequest(method, path, bytes.NewReader(jsonByte)) w := httptest.NewRecorder() context := new(ctx.Context) req.Header.Set(&quot;Content-Type&quot;, &quot;application/json&quot;) req.Header.Set(&quot;Authorization&quot;, token) req = req.WithContext(context) r.ServeHTTP(w, req) return w}func TestCreateChannel(t *testing.T) { body := gin.H{ &quot;code&quot;: float64(200), } param := make(map[string]interface{}) param[&quot;name&quot;] = &quot;name&quot; param[&quot;contact&quot;] = &quot;123&quot; param[&quot;phone_number&quot;] = &quot;111&quot; router := InitRouterAdmin() token, tokenErr := GetAuthorization(&quot;1&quot;) if tokenErr != nil { t.Errorf(&quot;获取测试用户token失败:%v&quot;, tokenErr) } w := performRequest(param, token, router, &quot;POST&quot;, &quot;/admin/v1/user/create_channel&quot;) assert.Equal(t, http.StatusOK, w.Code) var response map[string]interface{} err := json.Unmarshal([]byte(w.Body.String()), &amp;response) value, exists := response[&quot;code&quot;] assert.Nil(t, err) assert.True(t, exists) assert.Equal(t, body[&quot;code&quot;], value)} 如果接口需要用到数据库，可以用 init() 启动。 编写产品代码： 12345678910111213141516171819202122232425262728293031func (u *ADMINUSER) CreateChannel(c *ctx.Context) { var response = new(proto.BaseResp) var code int var request = new(proto.CreateChannelRequest) defer c.JSON(code, response) apireturn := errs.ParameterError(&quot;传参有误&quot;) response.Code = apireturn.ErrorCode response.Msg = apireturn.Msg code = apireturn.Code if err := c.ShouldBind(&amp;request); err == nil { var CatChannels models.CatChannels CatChannels.Name = request.Name CatChannels.Contact = request.Contact CatChannels.PhoneNumber = request.PhoneNumber err := service.ChannelAdd(CatChannels) if err != nil { ret := errs.UnknownError(&quot;创建渠道失败&quot;) response.Code = ret.ErrorCode response.Msg = ret.Msg code = ret.Code return } response.Code = 200 response.Msg = &quot;success&quot; code = 200 }} 运行测试： 成功了。","link":"/2022/01/02/tdd/"},{"title":"2021年计划完成情况与2022年人生规划","text":"「时光不负，创作不停，本文正在参加 2021年终总结征文大赛」 去年参与的年终总结：https://juejin.cn/post/6910859711428427783 2021年计划完成情况事业我原本的计划是在2021年秋招前离职，因为目前公司业务很少，平常也不加班，有大量时间可以自学，我就想在公司再准备半年，秋招再面试大厂，目标拿到至少20k的薪资。 我打算这样做：在今年打牢算法基础，同时也要在工作中把项目做的更完整和有质量，但是现在公司只有我一个开发，做的项目感觉和之前做的也没有太大的区别，有很多重复的地方，所以怎样把项目做得更有质量，我觉得这是我现在主要该思考的方向。为了进一步提高作为专科程序员的我进入大厂的可能性，我需要提升自己的技术影响力，写技术文章（在个人博客，掘金）、参加技术大会、积极参与开源项目。 但是计划赶不上变化。2021年3月17日，公司在我完成最后一个项目后，将我在试用期满的前一天（试用期6个月）辞退，这让我猝不及防。我只能在春招找工作，而此时我并没有做好准备。找个好工作非常艰难，只好将目标定为在4月结束前找到一个18k以上稳定的工作，中小公司也可以。 4月拿到3个offer，最终决定入职某北京上市公司在杭州的分部，18k，双休，试用期不打折，五险一金交最低。之前我一直都在小公司做，工作中的项目用单体架构就足以应付了，这是我第一次尝试参与微服务架构的项目，公司自研的框架和微服务架构都是我很不熟悉的。公司的项目也是我做过最大的一个。 5月前往总部出差，疯狂加班写代码赶项目改bug，熟悉技术栈，在总部出差1个月，每个工作日都最起码22点后回酒店。 6月也是疯狂加班，通常22点后下班。这个月我导致了一个线上事故，有天下午老大临时让我加个线上需求，我很快速的做完了，但是我自测的不到位，没有考虑到影响范围，并且没有通知测试进行回归，导致晚饭时发现线上bug。虽然发现后立刻回滚，并修复了数据，即使如此还是损失了200多美元。从此告诫自己，写代码一定要严谨，要多自测，还好项目上线不久，还没开始加量，不然可就不止这200美元了。 7月，买了一台MacBookPro M1，从大学就开始用的笔记本终于退休了。这个月的工作日都在加班，休息日也会抽时间工作，所以没有时间做别的事。 8月，前公司（今年将我在试用期满的前一天辞退）找到我，希望我能回去维护项目，被我拒绝了。有点暗爽，当时还在想为什么他们完成项目就辞退我，不考虑后期维护的吗，原来是没想到项目还需要维护呀，但也可以理解，毕竟前公司是以销售为主的团队，老板也是销售出身。又坏又没技术，只能说可（huo）惜（gai）了。 9月，工资涨到20k。（2020年定下的工资flag达成了） 10月，产品经理离职，工作量徒然增大。工作日每天晚上到22点左右下班，缺少空闲的时间。 直到现在工作量也没有减少，因为公司目前缺少一个项目经验足、管理能力强的PM，老大是运营出身，不懂技术，需求和进度管理很混乱，大多数时候还是22点后下班，偶而加班到凌晨1点。 生活 除了春节跟我妈逛了一下西湖之外，原定的旅游计划一个也没有实现。今年工作太忙，虽然周末双休，但也只想待在家里恢复元气。本打算购入一台富士相机，但想想也没有时间拍摄，就算了吧。 坚持每天健身也没有做到。每天23点到家，哪还有精力健身呀，洗个澡，刷会儿手机就睡了。 买了升降桌、人体工学椅和走步机，尽量保持健康的工作。 周末开始尝试做菜，虽然挺难吃的。 女朋友没时间找。 今年看了《聆听音乐》一书，入坑了古典音乐。之后注册了Spotify的会员，买了索尼的降噪耳机，达尼的蓝牙音箱，平常会听一些古典、jazz、chill jazz、hiphop jazz、cool jazz、city pop类型的音乐。 今年通过小宇宙app入坑了播客，这是我收集的一些优质播客：https://www.yuque.com/reliable/ltx9ff/ibi9t5 入坑了Netflix，看完了《鱿鱼游戏》剧集，现在在看《王冠》。 学习 软件工程学习：通过公司项目学到了微服务架构与开发流程。 Go语言学习：看完了书籍《Effective Go》，《Go语言设计与实现》，毛老师在极客时间的《GO进阶训练营》看到了第7周。 代码修养学习：看完了书籍《代码整洁之道》，《程序员的职业素养》，看完了极客时间的课程《10x程序员工作法》。 Unity学习：看完了书籍《Unity 3D/2D手机游戏开发》。 哲学学习：看完了书籍《哲学简史》，《理想国》，《中国哲学简史》。 理财学习：看完了书籍《百万富翁快车道》。 2021年看完的书籍我的书单与笔记：https://www.yuque.com/reliable/ltx9ff 哲学类阅读：《哲学简史》，《理想国》，《中国哲学简史》 技术类阅读：《Effective Go》，《Go语言设计与实现》，《代码整洁之道》，《程序员的职业素养》 文学类阅读：《呐喊》，《三体（全集）》重读 理财类阅读：《百万富翁快车道》 历史类阅读：《先秦史》 科普类阅读：《花间美人》，《聆听音乐》，《1368个单词就够了》，《科幻文学论纲》 2022年规划精神生活对于我来说，生活的意义是什么？我认为生活本来就没有意义，意义是人为了自己的生存所构建出来的东西，是一种只存在于大脑的抽象，人的存活本质上来说只是一种物质反应，而生活的意义是人自己用头脑赋予的。去年在《幸福课》一书中看到很有意思的一句话：关于“人生的意义在哪里”这样的问题，我们都应该是问题的回答者，而不是简单的提问者。 我们寻找答案的过程本身，也许就是意义所在。 意义又是没有标准答案的，随着知识和经验的增长，我随时都有可能改变原有的看法，所以这是一个需要不断思考和更新的问题。我现在所认为的生活的意义，并不意味着以后不会改变。 有时候想起我总有一天会死亡，就感觉到一阵无力，对于无神论者来说，没有天堂、瓦尔哈拉或者轮回，死亡就是死亡，就是不再存在。于是我这样安慰自己：对于这个已经确定的，必然会发生的结局来说，生活中所遭受一切磨难和障碍就都显得微不足道了，还有什么比这必然发生的死亡更痛苦的吗？所以别去计较了，一定要珍惜眼前的生活，做自己该做的，投身于有价值的事业，“我们在这世上时日不多，不值得在可鄙的坏蛋的脚下爬行”。 投身于有价值的事业获取幸福的错误方法，莫过于追求纸醉金迷、纵情享乐，因为我们企图把悲惨的人生，变成接连不断的快感与刺激，而最终收获的往往只有空虚和无意义。 我想要成为一个创造者，想要创造一个作品，这样当我不在人世的时候也能给这个世界留下一些印记。俗话说，每个人都有两次死亡，一次是肉体死亡，一次是被遗忘。 我掌握计算机编程技术，这是我唯一可以用于工作的知识了，或许我可以用这门手艺帮助一些人，当然不是那种巨大的物质上的帮助，那我也做不到，只是给世界一点点小小的改善就心满意足了。或许我可以创造一些东西，帮助人们解决一个简单的问题，或者让人们更健康，更有营养，更快乐……我需要寻找一个东西，为我的事业充电。 或许我可以制作一款电子游戏，在我的设想中，如果将艺术性、游戏性和教育性结合起来，说不定会产生一些有意思的东西，游戏也被称为第九艺术，它是一个很合适的载体。当然我需要为此付出很多时间和精力去学习。 保持身体健康保持身体健康是头等大事，因为只要失去了健康，即使精神上得到的东西再多也没有意义。 我在2022年打算这样做： 坚持在每天23点洗澡，坚持在每天24点前睡觉，不熬夜 只要有时间就健身，平时可以多玩《健身环大冒险》、《ARMS》这种类型的游戏 吃的话不用太在意，想吃什么就吃什么，只要别吃很不健康的东西就行，不抽烟，不喝酒，不喝饮料。 财政状况我需要钱，而且来的越快越好叔本华这样定义金钱：如果一个人从一开始就拥有足够的财产，能够享受真正的独立自主，也就是说，不用操劳就能维持舒适的生活，那就是一个价值无法估量的优越条件。因为这是从大众的强制苦役中终获得了解放，而这苦役本是凡夫俗子的天然命运，只有命运垂青的人才可以是真正的自由，是自己的主人，因此也只有这样，这人才可以是自己的时间和自己的力量的主宰。 这就是金钱的力量，它能给你自由！有了金钱，你就可以远离老板和办公室，追求梦想，按照自己满意的方式生活。 当然，我不想看到自己为了金钱而牺牲自由与健康，在我看来这有点本末倒置、买椟还珠了。 我需要的是被动收入我需要一颗“摇钱树”，能让我不需要或尽量少的通过花费时间得到金钱，而不是像打工那样用5天时间换取2天自由。 在我的设想中有2棵“摇钱树”： 金融。如果我有房地产，我不需要花费时间，每月就能得到一笔租金。如果我有某样作品的版权，我也可以通过专利获得被动收入。或者我有一笔闲钱，我可以用这笔钱投资，得到更多钱。 计算机。电脑软件可以每天工作24小时，从不迟到早到，只是按照程序约定的去运行。或许可以通过开发独立软件获得被动收入。 我需要多少钱我需要被动收入覆盖过我的个人开支，最好不要让自己花太多时间在赚钱上，只是通过金融利息或软件系统获得收益是最好的。同时还要抵制消费主义，最好是低欲望的生活，其实有很多开支是没必要的，很多消费除了能让我的钱流通出去之外没有太多收益。 职业发展关于我的职业发展主要有3个方向，这3个方向在初期可以同时发展，在发展的过程中再去根据实际情况侧重于不同的路线： 公司打工路线：继续在公司发展，通过售卖工作时间赚取工资，提高面向公司的技术水平，尽可能跳槽到更大的公司，最终目标是在一个公司达到架构师或技术总监的位置。最好的结果是跳槽到一个跨国企业，但困难点在于需要学好英语。 自由职业路线：以学好英语为前提，通过国外的upwork和中国的程序员客栈等外包平台接单，保证能得到一线城市普通程序员的工资收益的情况下，再去房价更低但自然环境更优美的城市居住。 独立开发路线：以开发独立游戏为主，兼具开发app或网站、小程序等产品，通过售卖产品获取收益。这条路线是我在精神上最想去走的路线，但是也是最不稳定的路线，独立开发意味着需要更高的技术水准，而且无法保证百分百能赚到钱。 未来3年的打算： 2021、2022年先以公司打工路线为主，在业余时间学习英语和相关技术栈，同时在有时间的情况下开始尝试独立开发； 2022年在存款允许的情况下，可以在年末辞职，此时可以备考英语和学历，也可以尝试一些外包性质的工作或独立开发，然后于2023年拿到专升本学历后面试大厂或外企。 2023年拿到学历后，希望能跳槽到大厂或外企工作。当然如果2022年独立开发和自由职业可以达到收支平衡的话，可以再权衡一下，找一个更WLB的工作。 娱乐活动游戏我喜欢的游戏有《太阁立志传5》、《维多利亚2》、《十字军之王》系列、《文明》系列、《极乐迪斯科》、《神界原罪2》、《塞尔达传说》系列、《动物森友会》、《健身环大冒险》、《任天堂明星大乱斗》、《ARMS》、《超级马里奥制造》。 我喜欢玩单机游戏，特别是任天堂游戏，有时候我会在游戏上花费很多时间，这是一个困扰我的问题，对于控制游戏时间是我一直在努力的方向。我当然不能放弃游戏，它们是我的快乐源泉，但是也需要控制自己不要沉迷于此，这个世界上还有更多美好的东西，游戏应该浅尝辄止。 视频看视频作为一种娱乐消遣方式，是比较低级的，这种通过被动接收的方式对人的成长来说没有太多帮助。所以当我在通过看视频娱乐时，会先给自己立下几个条约： 不打开短视频app，它们是浪费时间、消磨意志的毒药 取消国内几个视频网站的会员，因为通常他们推荐的资源是低质量的（大部分情况） 通过Netflix观看剧集，如果一定要看视频的话，至少选个外语环境，学点外语吧 推荐几个我目前在看的视频：动画片有《瑞克与莫蒂》、《希尔达》，剧集有《宋飞正传》、《王冠》、《性爱自修室》、《毒枭》，纪录片有《我们的星球》、《头脑解密》，综艺有《粉雄救兵》 音乐与播客今年看了《聆听音乐》一书，入坑了古典音乐。之后注册了Spotify的会员，买了索尼的降噪耳机，达尼的蓝牙音箱，平常会听一些古典、jazz、chill jazz、hiphop jazz、cool jazz、city pop类型的音乐。 希望2022年有机会可以去现场听交响乐。 今年通过小宇宙app入坑了播客，这是我收集的一些优质播客：https://www.yuque.com/reliable/ltx9ff/ibi9t5 旅行与摄影打算购入一台富士相机，进行旅游拍摄。 2022年打算旅游的地点 千岛湖 西溪湿地 云南 阅读在我看来阅读是最好的一种娱乐方式了，除了阅读之外的娱乐方式多多少少会让人产生一种负罪感，而阅读则不会。网络小说除外。 我的书单：https://www.yuque.com/reliable/ltx9ff 学习计划计算机专业知识学习Go语言学习： 看完极客时间《Go进阶训练营》 参与一次GoCN社区举办的Go开发者大会 看完书籍《Go专家编程》 软件工程学习： 看完书籍《重构：改善既有代码的设计》 看完书籍《Google 软件测试之道》 操作系统学习： 看完书籍《现代操作系统》 算法学习： 看完极客时间《算法面试通关40讲》 运维学习： 看完书籍《SRE：Google运维解密》 数据库学习： 看完极客时间《MySQL实战45讲》 编译原理学习： 看完书籍《两周自制脚本语言》 看完书籍《计算机程序的构造和解释》 看完极客时间《编译原理之美》 英语学习 第一步，通过不背单词app背完一本3000词的英语单词书，累计原始词汇量。假设每天除了复习完还需要背诵60个新词，一周平均背5天，一个月大概背1300个单词，预计在2022年2月完成单词书的背诵。 第二步，累计原始词汇量之后，开始每周的英语学习计划： 周一，阅读英语文章一篇（推荐阅读左耳听风专栏提供的技术英语资源），在笔记本中写下一些新单词 周二，在笔记本上写下昨天、今天和明天所作的事情，写下前一天阅读内容的摘要，在笔记本中写下一些新单词 周三，观看英语节目，听英语歌曲，在笔记本中写下一些新单词 周四，聘请导师对话，谈一下前几天看的书、节目、歌曲（也可以自言自语） 周五，将前几天笔记本中写下的单词导入app，并进行背诵 周六和周日，找一首英语歌曲，找一篇英语文章，找一集英语节目 第三步，复习托福，打算在2023年进行英语托福考试。 独立游戏开发学习 完成独立游戏策划案 按照游戏所需的实现分别进行学习和实践 完成demo版本开发 哲学学习哲学学习是潜移默化的，虽然很重要，但未来还有很多的时间可以用来学习，不紧急。 我的哲学计划书单：https://www.yuque.com/reliable/ltx9ff/xirky1 投资理财相关知识学习目前对于投资理财的知识了解的还不够多，所以前期还是以存钱为主。可以花时间读一些投资理财相关的书籍，等觉得有把握了再进行投资理财。 我的理财相关知识计划书单：https://www.yuque.com/reliable/ltx9ff/lbd0wv","link":"/2022/01/02/2021end/"},{"title":"评选用于治疗低血压的“好代码”榜单","text":"经调查发现，当程序员看到这些奥妙无穷、灵气逼人、独具巧思的好代码时，血压便会急速上升，一边在内心啧啧感叹，嘴上也得说上两句甜蜜而亲切的话语。或可被用于治疗低血压。 Top 10 “沉默的羔羊” &amp;&amp; “唐僧崇拜者”“沉默的羔羊”是一群固执的信徒，他们坚守着一项古老的传统——不写注释！他们是实用主义者，通常认为有写注释的时间，还不如多摸会儿鱼，哦不，多写几行业务代码。但是当他人不写注释时，“沉默的羔羊”便一反常态的使用“双标”技能进行谴责，或许在他们看来，不写注释是只有高贵信徒才可以做的事情，凡人可不能学哦。 “唐僧崇拜者”则是另一个极端，是“沉默的羔羊”的反对派，他们极其酷爱写注释，并且认为注释越多越好。他们会为代码写一串长长的注释，用于解释代码运行所需的一切，但如果去掉注释，代码便极难看懂，不过没关系，代码看不懂？有注释呀！你看注释！ “沉默的羔羊”&amp;&amp;“唐僧崇拜者”本是一体两面，本质上都是对那些可以自解释的代码的蔑视，他们不认为代码可以有准确的命名与易懂的实现，于是一个选择破罐破摔，一个则选择用补丁堵住千疮百孔。所以两者并列 Top10。 Top 9 “暗影刺客”“暗影刺客”神出鬼没，分布在代码的各个角落，他们都有相似之处，但不全然相同。当程序员需要进行某些修改时，必须找出每个“暗影刺客”进行改动，否则可能会导致bug。如果一个需求需要修改的代码散步在各处，程序员不但很难找到他们，也很可能错过某个重要的修改。这就是他厉害的地方。 悄悄告诉你：有些程序员会使用“聚合代码”，将需要修改的代码汇聚到一处，写在一个方法或函数里，这样便可将修改处一并解决掉。 Top 8 “混乱法师”“混乱法师”掌握着一项神奇的技能，称为“魔法数字”，用起来很简单，就像这样： 1234567891011121314151617181920212223242526272829func GetGenderCoin(gender int) string { var coin string switch gender { case 1: coin = 6 case 2: coin = 5 default: coin = 5 } return coin}func GetCoinByGender(coin string) int { var gender int switch coin { case 6: gender = 1 case 5: gender = 2 default: gender = 2 } return gender } 这是一份很简单的示例，你或许可以猜出 case 1 和 case 2 分别是什么意思？好吧，不可能猜的出来。那么加上注释： 123456789101112func GetGenderCoin(gender int) string { // 女性返回 6 coin，男性或其他返回 5 coin // 1：女性，2：男性 ……}func GetCoinByGender(coin string) int { // 6 coin返回女性，5 coin或其他返回男性 ……} 在代码中，分别用了几个神秘的数字以标识 gender 和 coin 的类型，但不看注释的话极难理解。 这样的代码对于低血压人群来说是非常有帮助的。 悄悄告诉你：可以把“魔法数字”分别用常量或方法封装起来，在需要时直接调用常量或方法即可。 Top 7 “参数之炼金术师”“参数之炼金术师”擅长将一大串稀奇古怪的参数统统传入一个函数，然后在函数中架起一口大锅，把参数一一扔进去，最终将制成品return出来。就像这样： 123func alchemical(animals, flowers, eyes, nose, kangaroo, lightning, stone, hair string) int { ……} 悄悄告诉你：过长的参数列表常会令人迷惑，当遇到这种情况可以考虑直接传入一个数据结构哦。 Top 6 “代码巨魔”“代码巨魔”诞生于上古时代，并一直延续至今。程序员们通常都知道“代码越长，越难理解”的道理，但“代码巨魔”却坚持己见，他们创造出的一个个动辄上千行的函数，是如此巨大，让人闻之瑟瑟发抖。 悄悄告诉你：面对“代码巨魔”，我们可以先通读一遍函数，理清思路，然后着手“重构”，将其切分成小的模块。 Top 5 “恶趣味的天才”天才很迷人，但“恶趣味的天才”是否迷人呢？“恶趣味的天才”总是会写一些“聪明的”代码，明明可以用更易懂的方式表达，但他们偏不。 就像这行代码，普通人难以看懂： 1const record = isOK &gt; isVip ? &quot;ok?&quot; : isVip &gt; isTime ? &quot;vip!&quot; : null; 悄悄告诉你：设计程序时一定要考虑怎样做能达到最小复杂度，设计的首要目标就是要让复杂度变小，要避免做出“聪明的”设计，因为“聪明的”设计常常都是难以理解的。 Top 4 “命名学家”“命名学家”的命名功力深不可测，他们精通各种命名方法，比如下面这些： 1234567891011121314// 脸滚键盘式命名dsadasj := &quot;脸滚键盘式命名&quot;// 中文拼音式命名zhonwenpinyin := &quot;中文拼音式命名&quot;// 极简主义式命名t := &quot;极简主义式命名&quot;// 丑陋不堪式命名nOtvIP := &quot;丑陋不堪式命名&quot;// 全部大写式命名NOTVIP := &quot;全部大写式命名&quot; 有些程序员会深思熟虑的给函数与变量命名，最终使得其命名可以清晰的解释出对应的功能与用法。而“命名学家”则不屑一顾。 悄悄告诉你：如果一个命名不能表明其功能，则命名无意义，除非是用过就丢的那种变量（比如这种 for var i=1; i &lt; 5; i++）。如果命名足够好，甚至不需要注释就能看懂一段代码的含义。 Top 3 “来自嵌套地狱的使者”“来自嵌套地狱的使者”带来了一页代码，让我们看一下： ok，硬了，拳头硬了。 Top 2 “恐怖天使”“恐怖天使”又被称为“全局变量”或“可变数据”，她像天使一样照顾着项目里每一处可以引用到她的地方，但她不是常量，一旦被修改，她就变身恐怖天使，令人闻之颤抖。 对数据的修改经常导致出乎意料的的结果和难以发现的bug。我在一处更新数据，却没有意识到软件中的另一处期望着完全不同的数据，于是一个功能就失效了，而且找出故障的原因也会非常困难。 悄悄告诉你：可以将“可变数据”封装起来，写一个查询方法专门用来获取这些值。 Top 1 “上古之神的低语”“上古之神的低语”渊源流长，他是一整套巨大的代码集合，在这其中有许许多多程序员参与其中，交付于多人之手，程序员来来去去，最终形成一个令人闻风丧胆的项目。 通常，在这种项目中会聚集 Top 10 - Top 1 的各路好汉，八仙过海，各显神通。听说曾经有一个同事抱怨一个项目的一处代码太烂，一查提交记录，好家伙，他自己写的；听说曾有人修改过这个项目的一处代码，好家伙，一测试，八竿子打不着的地方出bug了。 像这种巨石一般的项目已经不是一个人单枪匹马能解决的了，要么重开，要么只能投入精力重构。 做程序员几年来，多多少少也见过了一些“好的代码”，遂至年末，便想要拿出来评选一番。这些代码都是日常遇到过的“好东西”，如果还有遗珠的话，也只能怪作者见识不够广博，还请谅解。至于排名，权当作笑料便可。","link":"/2022/01/02/nicecode/"},{"title":"Brendel","text":"介绍 阿尔弗雷德·布伦德尔（德语：Alfred Brendel，1931年1月5日－），奥地利钢琴家。 布伦德尔6岁开始学琴。14岁那年被派往南斯拉夫挖战壕，结果冻伤被送进医院。十六岁以后他没有再受到正规的音乐教育。战后，他在作曲的同时继续弹钢琴、绘画。在钢琴方面他基本上是自学成才。十七岁在格拉茨举办了他的第一场公开独奏会，在会上演奏了巴赫、勃拉姆斯、李斯特等人的赋格作品和几首自己作的曲子。在那之后，他放弃了作曲，开始专攻钢琴。 布伦德尔的演奏有时候会被形容为再解析音乐，对此他表示作为钢琴家的首要任务是尊重作曲家的意愿，而不是表现自己或加入自己的见解。 布伦德尔被认为是现今德国古典作曲家如贝多芬、舒伯特和莫扎特等人作品最具思想性的诠释者。他是学者型的钢琴家，对演奏的每一部作品都要潜心研究，深入探索，以揭示深刻的内涵。但他的演奏并不刻板，而是非常浪漫抒情。 布伦德尔是当今最权威的舒伯特专家，对舒伯特的作品有独到的研究。1978年全世界纪念舒伯特逝世150周年，他的舒伯特作品系列演奏会与13集电视系列片《布伦德尔演奏舒伯特》是“舒伯特年”的重头戏，他在节目中对每一首奏鸣曲都做了详尽的介绍。他70年代和80年代两次在飞利浦公司录制舒伯特全部钢琴作品。他演奏的舒伯特奏鸣曲当然是权威的阐释。 推荐专辑 《The Legendary Early Recordings: Alfred Brendel》（早期传奇唱片：阿尔弗雷德·布伦德尔）共10卷，基本上是对贝多芬作品的演奏 《Schumann: Piano Concerto / Brahms: Variations &amp; Fugue on a Theme by Handel》（舒曼：钢琴协奏曲/勃拉姆斯：亨德尔主题变奏曲和赋格曲） 《Brendel spielt Mozart》（布伦德尔演奏莫扎特） 《Schubert: Moments Musicaux; Piano Sonata in B Flat, D.960》（舒伯特：音乐的时刻；降B调钢琴奏鸣曲，D.960） 《Alfred Brendel - Liszt - Artist’s Choice》（阿尔弗雷德·布伦德尔-李斯特-艺术家的选择） 《Mozart: Piano Sonatas K.310, K.311 &amp; K.533/494》（莫扎特：钢琴奏鸣曲K.310、K.311和K.533/494） 《Schumann: Kreisleriana; Kinderszenen; Fantasiestücke》（舒曼：克里斯利亚纳；场景；幻想） 《Mozart: Favourite Works for Piano》（莫扎特：最受欢迎的钢琴作品） 《Alfred Brendel: The Farewell Concerts》（布伦德尔 08年告别音乐会 / 维也纳与汉诺威现场录音） 相关诠释者：贝多芬；舒曼；勃拉姆斯；莫扎特；舒伯特；李斯特","link":"/2022/01/03/Brendel/"}],"tags":[{"name":"关于我","slug":"关于我","link":"/tags/%E5%85%B3%E4%BA%8E%E6%88%91/"},{"name":"TDD","slug":"TDD","link":"/tags/TDD/"},{"name":"测试驱动开发","slug":"测试驱动开发","link":"/tags/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"},{"name":"年终总结","slug":"年终总结","link":"/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"name":"2021","slug":"2021","link":"/tags/2021/"},{"name":"音乐家","slug":"音乐家","link":"/tags/%E9%9F%B3%E4%B9%90%E5%AE%B6/"}],"categories":[{"name":"关于我","slug":"关于我","link":"/categories/%E5%85%B3%E4%BA%8E%E6%88%91/"},{"name":"代码修养","slug":"代码修养","link":"/categories/%E4%BB%A3%E7%A0%81%E4%BF%AE%E5%85%BB/"},{"name":"个人总结","slug":"个人总结","link":"/categories/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"},{"name":"音乐家","slug":"音乐家","link":"/categories/%E9%9F%B3%E4%B9%90%E5%AE%B6/"}]}